# Linear Combination of Unitaries (LCU)

This repo contains a working, readable implementation of the **Linear Combination of Unitaries (LCU)** construction in Qiskit using the standard **PREPARE → SELECT → UNPREPARE** pattern, with **postselection** on the ancilla register.

It is meant as a learning friendly reference. You can plug in coefficients and Pauli strings (or circuits / matrices), build the LCU unitary, run it on Aer, and compare **empirical** vs **theoretical** postselection success probability.

> Note on equations in GitHub README  
> GitHub Markdown does **not** natively render LaTeX in `$...$` or `$$...$$`.  
> To make equations render reliably on GitHub, this README uses **SVG images** generated by GitHub’s math renderer:
> `https://render.githubusercontent.com/render/math?math=...`

---

## What this repo implements

You start with an operator written as a linear combination of unitaries:

<img src="https://render.githubusercontent.com/render/math?math=A%20%3D%20%5Csum_%7Bj%3D0%7D%5E%7BL-1%7D%20%5Calpha_j%20U_j" />

where <img src="https://render.githubusercontent.com/render/math?math=%5Calpha_j%20%5Cin%20%5Cmathbb%7BC%7D" /> and each <img src="https://render.githubusercontent.com/render/math?math=U_j" /> is unitary.

Since a quantum circuit must be unitary, you do not implement <img src="https://render.githubusercontent.com/render/math?math=A" /> directly. Instead, you build a larger unitary <img src="https://render.githubusercontent.com/render/math?math=W" /> such that when you apply it to <img src="https://render.githubusercontent.com/render/math?math=%7C0%5Crangle_%7B%5Ctext%7Banc%7D%7D%7C%5Cpsi%5Crangle_%7B%5Ctext%7Btgt%7D%7D" /> and postselect the ancilla on <img src="https://render.githubusercontent.com/render/math?math=%7C0%5Ccdots%200%5Crangle" />, the target behaves like <img src="https://render.githubusercontent.com/render/math?math=A%7C%5Cpsi%5Crangle" /> up to scaling:

<img src="https://render.githubusercontent.com/render/math?math=%28%5Clangle%200%5Ccdots%200%7C_%7B%5Ctext%7Banc%7D%7D%20%5Cotimes%20I%29%20W%20%28%7C0%5Ccdots%200%5Crangle_%7B%5Ctext%7Banc%7D%7D%20%5Cotimes%20%7C%5Cpsi%5Crangle_%7B%5Ctext%7Btgt%7D%7D%29%20%5Cpropto%20A%7C%5Cpsi%5Crangle" />

---

## Algorithm, as implemented

### 1. Coefficient preprocessing

Each coefficient is split into magnitude and phase:

<img src="https://render.githubusercontent.com/render/math?math=%5Calpha_j%20%3D%20%7C%5Calpha_j%7C%20e%5E%7Bi%5Cphi_j%7D" />

Define:

<img src="https://render.githubusercontent.com/render/math?math=%5Clambda%20%3D%20%5Csum_j%20%7C%5Calpha_j%7C%2C%20%5Cqquad%20p_j%20%3D%20%7C%5Calpha_j%7C%20%2F%20%5Clambda" />

The ancilla amplitude vector is built using:

<img src="https://render.githubusercontent.com/render/math?math=%5Cbeta_j%20%3D%20%5Csqrt%7Bp_j%7D%20%3D%20%5Csqrt%7B%7C%5Calpha_j%7C%20%2F%20%5Clambda%7D" />

and padded to size <img src="https://render.githubusercontent.com/render/math?math=2%5Em" /> where <img src="https://render.githubusercontent.com/render/math?math=m%20%3D%20%5Clceil%20%5Clog_2%20L%20%5Crceil" />.

---

### 2. PREPARE oracle

PREPARE maps the all zero ancilla state to an index superposition encoding coefficient magnitudes:

<img src="https://render.githubusercontent.com/render/math?math=%5Ctext%7BPREPARE%7D%20%7C0%5Ccdots%200%5Crangle%20%3D%20%5Csum_j%20%5Csqrt%7Bp_j%7D%20%7Cj%5Crangle" />

This repo contains two variants:

- **Baseline**: uses Qiskit `StatePreparation` directly for PREPARE and PREPARE†.
- **Decomposed (educational)**: inlines PREPARE and PREPARE† so you can see the decomposition, and targets a restricted gate set (a special mode aiming for only `ry` and `cx`).

Important note: preparing a general complex state using only {`ry`, `cx`} is not possible in general. The decomposed variant enforces **real amplitude** state preparation and will raise an error if nontrivial phases are present.

---

### 3. SELECT oracle

SELECT applies the right unitary conditioned on the ancilla index:

<img src="https://render.githubusercontent.com/render/math?math=%5Ctext%7BSELECT%7D%20%3D%20%5Csum_j%20%7Cj%5Crangle%5Clangle%20j%7C%20%5Cotimes%20e%5E%7Bi%5Cphi_j%7D%20U_j" />

Implementation strategy used here:

1. Loop over each term <img src="https://render.githubusercontent.com/render/math?math=j" />
2. Flip ancilla bits so the branch <img src="https://render.githubusercontent.com/render/math?math=%7Cj%5Crangle" /> maps to <img src="https://render.githubusercontent.com/render/math?math=%7C11%5Ccdots%201%5Crangle" />
3. Apply a controlled phase <img src="https://render.githubusercontent.com/render/math?math=e%5E%7Bi%5Cphi_j%7D" /> on that branch
4. Apply the controlled <img src="https://render.githubusercontent.com/render/math?math=U_j" />
5. Undo the flips

Supported <img src="https://render.githubusercontent.com/render/math?math=U_j" /> formats:

- Pauli strings like `XYZZY` (fast path)
- `QuantumCircuit`
- numpy matrices
- callables for custom behavior

---

### 4. UNPREPARE and postselection

The full LCU unitary is:

<img src="https://render.githubusercontent.com/render/math?math=W%20%3D%20%28%5Ctext%7BPREPARE%7D%5E%7B%5Cdagger%7D%20%5Cotimes%20I%29%20%5Ccdot%20%5Ctext%7BSELECT%7D%20%5Ccdot%20%28%5Ctext%7BPREPARE%7D%20%5Cotimes%20I%29" />

Finally, measure the ancilla and postselect on:

<img src="https://render.githubusercontent.com/render/math?math=%7C0%5Ccdots%200%5Crangle_%7B%5Ctext%7Banc%7D%7D" />

---

## Success probability

For the postselected construction, the success probability is:

<img src="https://render.githubusercontent.com/render/math?math=p_%7B%5Ctext%7Bsuccess%7D%7D%20%3D%20%7C%7C%20A%7C%5Cpsi%5Crangle%20%7C%7C%5E2%20%2F%20%5Clambda%5E2" />

This repo reports:

- **Empirical** <img src="https://render.githubusercontent.com/render/math?math=p_%7B%5Ctext%7Bsuccess%7D%7D" />: fraction of shots where ancilla measured `0...0`
- **Theoretical** <img src="https://render.githubusercontent.com/render/math?math=p_%7B%5Ctext%7Bsuccess%7D%7D" />: computed by explicitly forming <img src="https://render.githubusercontent.com/render/math?math=A%7C%5Cpsi%5Crangle" /> when the unitaries are representable as matrices (Pauli strings or explicit gates)

When <img src="https://render.githubusercontent.com/render/math?math=%5Clambda" /> is large, postselection becomes unlikely. In full scale algorithms, this is typically handled with amplitude amplification (not implemented here).

---

## Repository structure

- `main.py`  
  Baseline LCU implementation using `StatePreparation` blocks for PREPARE / PREPARE†. Includes parsing helpers, controlled Pauli string implementation, circuit builder, Aer sampling, and empirical vs theoretical probability reporting.

- `main_stateprep_decomposed.py`  
  Variant that inlines state preparation and attempts to decompose PREPARE / PREPARE† down to a very restricted gate set (aiming for `ry` and `cx`). Primarily for circuit inspection and learning. Enforces real statevectors for that restriction.

---

## Installation

```bash
pip install qiskit qiskit-aer matplotlib numpy
